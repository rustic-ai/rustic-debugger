import { DocumentationPage } from '@/types/DocumentationPage';
import { NavigationStructure, NavigationCategory, NavigationSection, NavigationPageRef, BreadcrumbNavigation, BreadcrumbItem, TableOfContents, TOCItem } from '@/types/NavigationStructure';
import path from 'path';

export interface NavigationBuilderOptions {
  maxDepth: number;
  defaultExpanded: boolean;
  sortBy: 'order' | 'title' | 'date';
  generateBreadcrumbs: boolean;
  generateTOC: boolean;
  tocMaxDepth: number;
}

export interface NavigationBuildResult {
  navigation: NavigationStructure;
  pageMap: Map<string, NavigationPageRef>;
  categoryMap: Map<string, NavigationCategory>;
  sectionMap: Map<string, NavigationSection>;
}

export class NavigationBuilder {
  private options: NavigationBuilderOptions;
  private pages: DocumentationPage[] = [];
  private pageMap = new Map<string, NavigationPageRef>();
  private categoryMap = new Map<string, NavigationCategory>();
  private sectionMap = new Map<string, NavigationSection>();

  constructor(options: NavigationBuilderOptions) {
    this.options = options;
  }

  buildNavigation(pages: DocumentationPage[]): NavigationBuildResult {
    this.pages = pages;
    this.pageMap.clear();
    this.categoryMap.clear();
    this.sectionMap.clear();

    // Step 1: Create page references
    const pageRefs = this.createPageReferences(pages);

    // Step 2: Build category structure
    const categories = this.buildCategories(pageRefs);

    // Step 3: Populate backlinks
    this.populateBacklinks(pages);

    // Step 4: Create navigation structure
    const navigation: NavigationStructure = {
      categories,
      maxDepth: this.options.maxDepth,
      collapsible: true,
      searchable: true,
      autoGenerated: true,
      lastGenerated: new Date()
    };

    return {
      navigation,
      pageMap: this.pageMap,
      categoryMap: this.categoryMap,
      sectionMap: this.sectionMap
    };
  }

  private createPageReferences(pages: DocumentationPage[]): NavigationPageRef[] {
    const pageRefs: NavigationPageRef[] = [];

    for (const page of pages) {
      const pageRef: NavigationPageRef = {
        id: page.id,
        title: page.title,
        path: `/${page.slug}`,
        order: page.sidebar.order,
        description: page.description,
        lastModified: page.lastModified,
        estimatedReadTime: page.estimatedReadTime,
        isDraft: this.isDraft(page),
        isNew: this.isNew(page),
        isUpdated: this.isUpdated(page)
      };

      // Add badge based on status
      if (pageRef.isNew) {
        pageRef.badge = { text: 'New', variant: 'new' };
      } else if (pageRef.isUpdated) {
        pageRef.badge = { text: 'Updated', variant: 'updated' };
      } else if (pageRef.isDraft) {
        pageRef.badge = { text: 'Draft', variant: 'draft' };
      }

      pageRefs.push(pageRef);
      this.pageMap.set(page.id, pageRef);
    }

    return this.sortPageReferences(pageRefs);
  }

  private buildCategories(pageRefs: NavigationPageRef[]): NavigationCategory[] {
    const categoryGroups = this.groupByCategory(pageRefs);
    const categories: NavigationCategory[] = [];

    for (const [categoryId, categoryPages] of categoryGroups) {
      const categoryInfo = this.getCategoryInfo(categoryId);
      const sections = this.buildSections(categoryPages);
      const directPages = categoryPages.filter(page => !this.getPageSection(page.id));

      const category: NavigationCategory = {
        id: categoryId,
        title: categoryInfo.title,
        description: categoryInfo.description,
        icon: categoryInfo.icon,
        order: categoryInfo.order,
        sections,
        pages: this.sortPageReferences(directPages),
        expanded: this.options.defaultExpanded
      };

      categories.push(category);
      this.categoryMap.set(categoryId, category);
    }

    return categories.sort((a, b) => a.order - b.order);
  }

  private buildSections(pages: NavigationPageRef[]): NavigationSection[] {
    const sectionGroups = this.groupBySection(pages);
    const sections: NavigationSection[] = [];

    for (const [sectionId, sectionPages] of sectionGroups) {
      if (!sectionId) continue; // Skip pages without sections

      const sectionInfo = this.getSectionInfo(sectionId);
      const subsections = this.buildSubsections(sectionPages);
      const directPages = sectionPages.filter(page => !this.getPageSubsection(page.id));

      const section: NavigationSection = {
        id: sectionId,
        title: sectionInfo.title,
        description: sectionInfo.description,
        order: sectionInfo.order,
        pages: this.sortPageReferences(directPages),
        subsections,
        expanded: this.options.defaultExpanded
      };

      sections.push(section);
      this.sectionMap.set(sectionId, section);
    }

    return sections.sort((a, b) => a.order - b.order);
  }

  private buildSubsections(pages: NavigationPageRef[]): NavigationSection[] {
    const subsectionGroups = this.groupBySubsection(pages);
    const subsections: NavigationSection[] = [];

    for (const [subsectionId, subsectionPages] of subsectionGroups) {
      if (!subsectionId) continue;

      const subsectionInfo = this.getSectionInfo(subsectionId);

      const subsection: NavigationSection = {
        id: subsectionId,
        title: subsectionInfo.title,
        description: subsectionInfo.description,
        order: subsectionInfo.order,
        pages: this.sortPageReferences(subsectionPages),
        expanded: this.options.defaultExpanded
      };

      subsections.push(subsection);
    }

    return subsections.sort((a, b) => a.order - b.order);
  }

  private groupByCategory(pages: NavigationPageRef[]): Map<string, NavigationPageRef[]> {
    const groups = new Map<string, NavigationPageRef[]>();

    for (const page of pages) {
      const pageData = this.pages.find(p => p.id === page.id);
      if (!pageData) continue;

      const category = pageData.sidebar.category;
      if (!groups.has(category)) {
        groups.set(category, []);
      }
      groups.get(category)!.push(page);
    }

    return groups;
  }

  private groupBySection(pages: NavigationPageRef[]): Map<string | null, NavigationPageRef[]> {
    const groups = new Map<string | null, NavigationPageRef[]>();

    for (const page of pages) {
      const section = this.getPageSection(page.id);
      if (!groups.has(section)) {
        groups.set(section, []);
      }
      groups.get(section)!.push(page);
    }

    return groups;
  }

  private groupBySubsection(pages: NavigationPageRef[]): Map<string | null, NavigationPageRef[]> {
    const groups = new Map<string | null, NavigationPageRef[]>();

    for (const page of pages) {
      const subsection = this.getPageSubsection(page.id);
      if (!groups.has(subsection)) {
        groups.set(subsection, []);
      }
      groups.get(subsection)!.push(page);
    }

    return groups;
  }

  private getPageSection(pageId: string): string | null {
    const page = this.pages.find(p => p.id === pageId);
    return page?.sidebar.section || null;
  }

  private getPageSubsection(pageId: string): string | null {
    const page = this.pages.find(p => p.id === pageId);
    // Extract subsection from section path (e.g., "getting-started/installation" -> "installation")
    const section = page?.sidebar.section;
    if (section && section.includes('/')) {
      return section.split('/')[1];
    }
    return null;
  }

  private getCategoryInfo(categoryId: string) {
    const categoryData = {
      'user-guide': {
        title: 'User Guide',
        description: 'How to use Rustic Debug for everyday debugging tasks',
        icon: 'user',
        order: 1
      },
      'dev-guide': {
        title: 'Developer Guide',
        description: 'Technical documentation for developers and integrators',
        icon: 'code',
        order: 2
      },
      'api': {
        title: 'API Reference',
        description: 'Complete API documentation and examples',
        icon: 'api',
        order: 3
      },
      'examples': {
        title: 'Examples',
        description: 'Code examples and sample implementations',
        icon: 'example',
        order: 4
      }
    };

    return categoryData[categoryId] || {
      title: categoryId.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase()),
      description: `Documentation for ${categoryId}`,
      icon: 'docs',
      order: 999
    };
  }

  private getSectionInfo(sectionId: string) {
    // Extract section info from ID or use defaults
    const sectionData = {
      'getting-started': { title: 'Getting Started', description: 'Quick start guide', order: 1 },
      'installation': { title: 'Installation', description: 'Installation instructions', order: 2 },
      'configuration': { title: 'Configuration', description: 'Configuration options', order: 3 },
      'usage': { title: 'Usage', description: 'Usage examples', order: 4 },
      'troubleshooting': { title: 'Troubleshooting', description: 'Common issues and solutions', order: 5 },
      'advanced': { title: 'Advanced Topics', description: 'Advanced configuration and usage', order: 6 }
    };

    return sectionData[sectionId] || {
      title: sectionId.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase()),
      description: `${sectionId} documentation`,
      order: 999
    };
  }

  private sortPageReferences(pages: NavigationPageRef[]): NavigationPageRef[] {
    switch (this.options.sortBy) {
      case 'title':
        return pages.sort((a, b) => a.title.localeCompare(b.title));
      case 'date':
        return pages.sort((a, b) => {
          const dateA = a.lastModified || new Date(0);
          const dateB = b.lastModified || new Date(0);
          return dateB.getTime() - dateA.getTime();
        });
      case 'order':
      default:
        return pages.sort((a, b) => a.order - b.order);
    }
  }

  private populateBacklinks(pages: DocumentationPage[]): void {
    const linkMap = new Map<string, Set<string>>();

    // Build map of page -> pages that link to it
    for (const page of pages) {
      for (const link of page.internalLinks) {
        const targetPage = this.findPageByLink(link, pages);
        if (targetPage) {
          if (!linkMap.has(targetPage.id)) {
            linkMap.set(targetPage.id, new Set());
          }
          linkMap.get(targetPage.id)!.add(page.id);
        }
      }
    }

    // Update backlinks
    for (const page of pages) {
      const backlinks = linkMap.get(page.id);
      if (backlinks) {
        page.backlinks = Array.from(backlinks);
      }
    }
  }

  private findPageByLink(link: string, pages: DocumentationPage[]): DocumentationPage | null {
    // Try to find page by slug, ID, or file path
    return pages.find(page =>
      page.slug === link.replace(/^\//, '') ||
      page.id === link ||
      page.filePath.includes(link)
    ) || null;
  }

  private isDraft(page: DocumentationPage): boolean {
    return page.filePath.includes('/drafts/') ||
           page.filePath.includes('draft-') ||
           page.tags?.includes('draft') ||
           false;
  }

  private isNew(page: DocumentationPage): boolean {
    const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
    return page.lastModified > oneWeekAgo;
  }

  private isUpdated(page: DocumentationPage): boolean {
    const twoWeeksAgo = new Date(Date.now() - 14 * 24 * 60 * 60 * 1000);
    const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
    return page.lastModified > twoWeeksAgo && page.lastModified <= oneWeekAgo;
  }

  generateBreadcrumbs(pageId: string): BreadcrumbNavigation {
    const page = this.pages.find(p => p.id === pageId);
    if (!page) {
      return { items: [], separator: ' > ' };
    }

    const items: BreadcrumbItem[] = [];

    // Add home
    items.push({
      title: 'Home',
      path: '/',
      isActive: false
    });

    // Add category
    const categoryInfo = this.getCategoryInfo(page.sidebar.category);
    items.push({
      title: categoryInfo.title,
      path: `/${page.sidebar.category}`,
      isActive: false
    });

    // Add section if exists
    if (page.sidebar.section) {
      const sectionInfo = this.getSectionInfo(page.sidebar.section);
      items.push({
        title: sectionInfo.title,
        path: `/${page.sidebar.category}/${page.sidebar.section}`,
        isActive: false
      });
    }

    // Add current page
    items.push({
      title: page.title,
      path: `/${page.slug}`,
      isActive: true
    });

    return {
      items,
      separator: ' > '
    };
  }

  generateTableOfContents(page: DocumentationPage): TableOfContents {
    if (!this.options.generateTOC) {
      return { items: [], maxDepth: 0 };
    }

    const tocItems: TOCItem[] = [];
    const headingStack: TOCItem[] = [];

    for (const heading of page.headings || []) {
      if (heading.level > this.options.tocMaxDepth) continue;

      const tocItem: TOCItem = {
        id: heading.id,
        text: heading.text,
        level: heading.level,
        anchor: heading.anchor,
        children: []
      };

      // Find the right parent level
      while (headingStack.length > 0 && headingStack[headingStack.length - 1].level >= heading.level) {
        headingStack.pop();
      }

      if (headingStack.length === 0) {
        // Top level heading
        tocItems.push(tocItem);
      } else {
        // Nested heading
        const parent = headingStack[headingStack.length - 1];
        parent.children = parent.children || [];
        parent.children.push(tocItem);
      }

      headingStack.push(tocItem);
    }

    return {
      items: tocItems,
      maxDepth: this.options.tocMaxDepth
    };
  }

  findPageByPath(path: string): NavigationPageRef | null {
    const slug = path.replace(/^\//, '').replace(/\/$/, '');
    for (const [, pageRef] of this.pageMap) {
      if (pageRef.path.replace(/^\//, '').replace(/\/$/, '') === slug) {
        return pageRef;
      }
    }
    return null;
  }

  getNavigationPath(pageId: string): NavigationPageRef[] {
    const path: NavigationPageRef[] = [];
    const page = this.pageMap.get(pageId);

    if (!page) return path;

    // Build path from root to current page
    const pageData = this.pages.find(p => p.id === pageId);
    if (!pageData) return path;

    // Add category page if it exists
    const categoryPage = this.findCategoryIndexPage(pageData.sidebar.category);
    if (categoryPage) {
      path.push(categoryPage);
    }

    // Add section page if it exists
    if (pageData.sidebar.section) {
      const sectionPage = this.findSectionIndexPage(pageData.sidebar.category, pageData.sidebar.section);
      if (sectionPage) {
        path.push(sectionPage);
      }
    }

    // Add current page
    path.push(page);

    return path;
  }

  private findCategoryIndexPage(category: string): NavigationPageRef | null {
    for (const [, pageRef] of this.pageMap) {
      const pageData = this.pages.find(p => p.id === pageRef.id);
      if (pageData?.sidebar.category === category &&
          (pageRef.path.endsWith(`/${category}`) || pageRef.path.endsWith(`/${category}/index`))) {
        return pageRef;
      }
    }
    return null;
  }

  private findSectionIndexPage(category: string, section: string): NavigationPageRef | null {
    for (const [, pageRef] of this.pageMap) {
      const pageData = this.pages.find(p => p.id === pageRef.id);
      if (pageData?.sidebar.category === category &&
          pageData?.sidebar.section === section &&
          (pageRef.path.endsWith(`/${section}`) || pageRef.path.endsWith(`/${section}/index`))) {
        return pageRef;
      }
    }
    return null;
  }

  getAdjacentPages(pageId: string): { previous?: NavigationPageRef; next?: NavigationPageRef } {
    const currentPage = this.pages.find(p => p.id === pageId);
    if (!currentPage) return {};

    // Get all pages in the same category and section
    const siblingPages = this.pages
      .filter(page =>
        page.sidebar.category === currentPage.sidebar.category &&
        page.sidebar.section === currentPage.sidebar.section
      )
      .sort((a, b) => a.sidebar.order - b.sidebar.order);

    const currentIndex = siblingPages.findIndex(page => page.id === pageId);
    if (currentIndex === -1) return {};

    const previous = currentIndex > 0 ? this.pageMap.get(siblingPages[currentIndex - 1].id) : undefined;
    const next = currentIndex < siblingPages.length - 1 ? this.pageMap.get(siblingPages[currentIndex + 1].id) : undefined;

    return { previous, next };
  }

  validateNavigation(): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Check for duplicate page paths
    const paths = new Set<string>();
    for (const [, pageRef] of this.pageMap) {
      if (paths.has(pageRef.path)) {
        errors.push(`Duplicate page path: ${pageRef.path}`);
      }
      paths.add(pageRef.path);
    }

    // Check for orphaned pages (pages not in any category)
    for (const page of this.pages) {
      const category = this.categoryMap.get(page.sidebar.category);
      if (!category) {
        errors.push(`Page "${page.title}" references non-existent category: ${page.sidebar.category}`);
      }
    }

    // Check for missing parent references
    for (const page of this.pages) {
      if (page.sidebar.parent) {
        const parentExists = this.pages.some(p => p.id === page.sidebar.parent);
        if (!parentExists) {
          errors.push(`Page "${page.title}" references non-existent parent: ${page.sidebar.parent}`);
        }
      }
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

export default NavigationBuilder;